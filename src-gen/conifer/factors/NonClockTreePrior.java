package conifer.factors;

import blang.core.ConstantSupplier;
import blang.core.DeboxedName;
import blang.core.ForwardSimulator;
import blang.core.LogScaleFactor;
import blang.core.Model;
import blang.core.ModelBuilder;
import blang.core.ModelComponent;
import blang.core.Param;
import blang.inits.Arg;
import briefj.collections.UnorderedPair;
import ca.ubc.stat.blang.StaticJavaUtils;
import conifer.TreeNode;
import conifer.UnrootedTree;
import conifer.factors.NonClockTreePriorUtils;
import conifer.factors.RealValuedDensity;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.function.Supplier;

@SuppressWarnings("all")
public class NonClockTreePrior implements Model, ForwardSimulator {
  public static class Builder implements ModelBuilder {
    @Arg
    public UnrootedTree tree;
    
    @Arg
    public RealValuedDensity branchLengthDensity;
    
    public NonClockTreePrior build() {
      // For each optional type, either get the value, or evaluate the ?: expression
      final UnrootedTree __tree = tree;
      final RealValuedDensity __branchLengthDensity = branchLengthDensity;
      // Build the instance after boxing params
      return new NonClockTreePrior(
        __tree, 
        new ConstantSupplier(__branchLengthDensity)
      );
    }
  }
  
  private final UnrootedTree tree;
  
  public UnrootedTree getTree() {
    return tree;
  }
  
  @Param
  private final Supplier<RealValuedDensity> $generated__branchLengthDensity;
  
  public RealValuedDensity getBranchLengthDensity() {
    return $generated__branchLengthDensity.get();
  }
  
  /**
   * Utility main method for posterior inference on this model
   */
  public static void main(final String[] arguments) {
    StaticJavaUtils.callRunner(Builder.class, arguments);
  }
  
  /**
   * Auxiliary method generated to translate:
   * { var result = 0.0 for (double edgeLength : tree.getBranchLengths.values) { result += branchLengthDensity.logDensity(edgeLength) } return result }
   */
  private static double $generated__0(final UnrootedTree tree, final RealValuedDensity branchLengthDensity) {
    double result = 0.0;
    Map<UnorderedPair<TreeNode, TreeNode>, Double> _branchLengths = tree.getBranchLengths();
    Collection<Double> _values = _branchLengths.values();
    for (final double edgeLength : _values) {
      double _result = result;
      double _logDensity = branchLengthDensity.logDensity(edgeLength);
      result = (_result + _logDensity);
    }
    return result;
  }
  
  public static class $generated__0_class implements LogScaleFactor {
    public double logDensity() {
      return $generated__0(tree, $generated__branchLengthDensity.get());
    }
    
    public String toString() {
      return "{ var result = 0.0 for (double edgeLength : tree.getBranchLengths.values) { result += branchLengthDensity.logDensity(edgeLength) } return result }";
    }
    
    private UnrootedTree tree;
    
    private Supplier<RealValuedDensity> $generated__branchLengthDensity;
    
    public $generated__0_class(final UnrootedTree tree, final Supplier<RealValuedDensity> $generated__branchLengthDensity) {
      this.tree = tree;
      this.$generated__branchLengthDensity = $generated__branchLengthDensity;
    }
  }
  
  /**
   * Auxiliary method generated to translate:
   * { tree.setTo(NonClockTreePriorUtils.sample(rand, branchLengthDensity, tree.leaves)) }
   */
  private static void $generated__1(final Random rand, final UnrootedTree tree, final RealValuedDensity branchLengthDensity) {
    List<TreeNode> _leaves = tree.leaves();
    UnrootedTree _sample = NonClockTreePriorUtils.sample(rand, branchLengthDensity, _leaves);
    tree.setTo(_sample);
  }
  
  /**
   * Note: the generated code has the following properties used at runtime:
   *   - all arguments are annotated with a BlangVariable annotation
   *   - params additionally have a Param annotation
   *   - the order of the arguments is as follows:
   *     - first, all the random variables in the order they occur in the blang file
   *     - second, all the params in the order they occur in the blang file
   * 
   */
  public NonClockTreePrior(@DeboxedName("tree") final UnrootedTree tree, @Param @DeboxedName("branchLengthDensity") final Supplier<RealValuedDensity> $generated__branchLengthDensity) {
    this.tree = tree;
    this.$generated__branchLengthDensity = $generated__branchLengthDensity;
  }
  
  /**
   * A component can be either a distribution, support constraint, or another model  
   * which recursively defines additional components.
   */
  public Collection<ModelComponent> components() {
    ArrayList<ModelComponent> components = new ArrayList();
    
    { // Code generated by: (tree, branchLengthDensity) { var result = 0.0 for (double edgeLength : tree.getBranchLengths.values) { result += branchLengthDensity.logDensity(edgeLength) } return result }
      // Construction and addition of the factor/model:
      components.add(
        new $generated__0_class(tree, $generated__branchLengthDensity));
    }
    
    return components;
  }
  
  public void generate(final Random rand) {
    $generated__1(rand, tree, $generated__branchLengthDensity.get());
  }
}
